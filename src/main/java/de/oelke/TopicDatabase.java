package de.oelke;

import de.hs8.ditop.datastructures.SubCollection;
import de.hs8.ditop.datastructures.Topic;
import de.hs8.ditop.helper.MallettResultsParser;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map.Entry;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.Vector;



/**
 * Determines discriminative topics. Expected input: Files produced by class
 * topic_modeling.MalletLDA.java For a definition of "discriminative" see
 * comment above method determineDistinctiveTopics().
 *
 * @author Daniela Oelke, Hendrik Strobelt
 * @created 08.03.2013
 */
public class TopicDatabase {

    /*
     * Key = name of class, value = instance of Subcollection which holds the
     * aggregated values for the class
     */
    private final HashMap<String, SubCollection> collection = new HashMap<String, SubCollection >();

    private final TreeMap<Integer, ArrayList<Double>> topicDistribution = new TreeMap<Integer, ArrayList<Double>>();

    private SubCollection allSubcollections = null;

    /* Key = topic id, value = a string with the terms that belong to the topic */
    private final HashMap<Integer, Topic> topicTerms = new HashMap<Integer, Topic>();

    public TopicDatabase() {
    }

    /**
     * loads topics from mallett output
     *
     * @param inputPath
     *            Path to input file (document topic file), format: column 1 =
     *            class name, column 2 = document name, all subsequent columns
     *            contain the probabilities of the topics. Column separator =
     *            ",", a header line is expected. Such a data format is
     *            generated by the class topic_modeling.MalletLDA.java
     *
     * @param topicTermPath
     *            Path to a file which contains a list of terms for each topic.
     *            One line per topic. Example line: TOPIC 29: graphic,
     *            application, data, render, client, ... Such a data format is
     *            generated by the class topic_modeling.MalletLDA.java
     * @throws FileNotFoundException
     * @throws IOException
     */
    public void loadData(final String inputPath, final String topicTermPath)
            throws FileNotFoundException, IOException {

        collection.clear();
        topicTerms.clear();

        /** Reading data in */
        final MallettResultsParser mallettResultsParser = new MallettResultsParser();
        allSubcollections = mallettResultsParser.readData(inputPath,
                collection, topicDistribution);
        mallettResultsParser.readTopicTerms(topicTermPath, topicTerms);
    }

    /**
     * This method determines the discriminative topics
     *
     *
     * @param significanceFactor
     *            The factor that the average probability value of a topic for
     *            class must be same or higher than for the other class(es) to
     *            deem the topic as distinctive for the class.
     *
     * @param entropyThreshold
     *            The minimum entropy value a topic must have to be considered a
     *            shared topic (see class GeneralTopicDeterminer.java)
     *
     * @throws IOException
     */
    public void determineDiscriminativeTopics(
            final double significanceFactor,
            final double entropyThreshold) throws IOException {

        final Set<Entry<Integer, Topic>> entrySet = topicTerms.entrySet();
        for (final Entry<Integer, Topic> entry : entrySet) {
            entry.getValue().cleanup();
        }

        /** Determine distinctive topics */
        determineDistinctiveTopics(significanceFactor);

        determineSharedTopics(entropyThreshold);

        //		/** Determine shared topics */
        //		final GeneralTopicDeterminer determiner = new GeneralTopicDeterminer();
        //		String sharedTopics = determiner.writeSharedTopicsToFile(inputPath,
        //				topicTermPath, outputPathShared, entropyThreshold);
        //
        //		sharedTopics = determiner.writeSharedTopicsToFile(inputPath,
        //				topicTermSummary, outputPathShared, entropyThreshold);
        //		System.out.println("\nSHARED TOPICS:");
        //		System.out.println(sharedTopics);

    }

    /**
     * Determines if a topic is discriminative for one or multiple classes.
     *
     * Underlying definition of "discriminative": The average probability values
     * of the class(es) must be at least times the given significanceFactor
     * higher than for all the other classes (= distinctive) and for all classes
     * for which the topic is considered discriminative, the average probability
     * value must at least equal the overall average probability value of the
     * topic (= characteristic).
     *
     * @param significanceFactor
     *            See comments for parameter significanceFactor of method
     *            determineDiscriminativeTopics()

     */
    private void determineDistinctiveTopics(final double significanceFactor)
            throws IOException {

		/* Preparations */

        // One vector per topic with one element per class (average probability values).
        // Idea: Eases comparing the values of different classes for a specific topic

        final Vector<Vector<ClassTopicValue>> topicValues = new Vector<Vector<ClassTopicValue>>(); //one position per topic, one TopicValue in inner vector per class
        boolean first = true;
        final Iterator<String> iter = collection.keySet().iterator();
        while (iter.hasNext()) {
            final String name = iter.next();
            final SubCollection subcollection = collection.get(name);
            final Vector<Double> summedValues = subcollection.getSummedValues();
            if (first) {
                first = false;
                for (int i = 0; i < summedValues.size(); i++) {
                    topicValues.add(new Vector<ClassTopicValue>());
                }
            }
            for (int i = 0; i < summedValues.size(); i++) {
                final double val = summedValues.get(i)
                        / subcollection.getNumberOfDocuments(); //average
                boolean isCharacteristic = false;
                if (val >= allSubcollections.getTopicSum(i)
                        / allSubcollections.getNumberOfDocuments())
                    isCharacteristic = true;
                topicValues.get(i).add(
                        new ClassTopicValue(name, val, isCharacteristic));
            }

        }

		/* Determine discriminative topics */
        for (int k = 0; k < topicValues.size(); k++) {
            final Vector<ClassTopicValue> topic = topicValues.get(k);
            final TreeSet<ClassTopicValue> candidates = new TreeSet<ClassTopicValue>(
                    new MyClassTopicComparator());
            Collections.sort(topic, new MyClassTopicComparator());
            double maxFactor = 0;
            for (int i = 0; i < topic.size() - 1; i++) {
                if (!topic.get(i).isCharacteristic()) {
                    break; //then neither this topic nor one of the following can be discriminative
                }
                if (topic.get(i).getValue() >= topic.get(i + 1).getValue()
                        * significanceFactor) {
                    final double significance = topic.get(i).getValue()
                            / topic.get(i + 1).getValue();
                    if (!(significance > maxFactor))
                        continue;
                    for (int j = i; j > -1; j--) {
                        candidates.add(topic.get(j));
                    }
                    maxFactor = significance;
                }
            }
            //			System.out.println(k + " cand:" + candidates);

			/* Write result to files and console. */
            if (candidates.size() > 0) {
                final Topic hs8Topic = topicTerms.get(k);
                hs8Topic.disValue = ((int) (maxFactor * 100)) / 100.0f;
                for (final ClassTopicValue value : candidates) {

                    hs8Topic.characteristicness.put(
                            value.getName(),
                            calcCharacteristicness(k,collection.get(value.getName())));
                }
            }
        }

    }

    /**
     * (c) Chris Rohrdantz
     *
     * @return the entropy of each topic vector (for a column)
     */
    private void determineSharedTopics(final double entropyThreshold) {
        final Set<Entry<Integer, ArrayList<Double>>> entrySet = topicDistribution
                .entrySet();
        for (final Entry<Integer, ArrayList<Double>> entry : entrySet) {
            final double d = calcTopicEntropy(entry.getValue());
            if (d > entropyThreshold)
                topicTerms.get(entry.getKey()).isShared = true;
        }

    }

    /**
     * (c) Chris Rohrdantz the entropy of one single column
     *
     * @param topicColumnVector
     * @return
     */
    private double calcTopicEntropy(final ArrayList<Double> topicColumnVector) {
        /** sum over all probabilities */
        double sumOfProbs = 0.0d;
        for (final double d : topicColumnVector) {
            sumOfProbs += d;
        }

        /** normalized values (conditioned probs p(D_i|T)) */
        final ArrayList<Double> normalizedTopicColumnVector = new ArrayList<Double>();
        for (final double d : topicColumnVector) {
            normalizedTopicColumnVector.add(d / sumOfProbs);
        }

        double entropy = 0.0d;
        double checkSum = 0.0d;
        for (final double d : normalizedTopicColumnVector) {
            //System.out.print(d + ", ");
            checkSum += d;
            //			entropy += (d * Math.log(d)/Math.log(2) );//is natural logarithm ok???
            /** H/Hmax */
            entropy += (d * Math.log(d) / Math.log(normalizedTopicColumnVector
                    .size()));//is natural logarithm ok???

        }
        //System.out.println("Check Sum = " + checkSum);

        entropy = -entropy;
        // TODO Auto-generated method stub
        return entropy;
    }

    /**
     * Currently, characteristicness is defined as the average probability of
     * the specific topic
     *
     * @return average probability
     */
    private double calcCharacteristicness(
            final int topicID,
            final SubCollection collection) {
        double value = collection.getSummedValues().get(topicID)
                / collection.getNumberOfDocuments();
        value = ((int) (value * 10000)) / 100.0; //Nur 2 Stellen hinter dem Komma und mal 100 genommen (da Durchschnitt Prozent)
        return value;
    }

    /**
     * Instances of this class are only temporarily needed in method
     * determineDistinctiveTopics(). Each instance holds the values for a
     * specific topic and a specific class.
     *
     * @author Daniela Oelke
     * @created 08.03.2013
     */
    class ClassTopicValue {

        /* Name of the class as used in instance variable "collection" */
        private final String name;

        /*
         * Probability value for the specific class for the topic that is
         * represented by this instance (usually average value of summed
         * probabilities)
         */
        private final Double value;

        /*
         * Set true if the value is high enough to be considered as
         * characterstic for the class (see comment above
         * determineDistinctiveTopics() for a definition of "characteristic").
         */
        private boolean isCharacteristic = false;

        public ClassTopicValue(final String name, final double value,
                               final boolean isCharacteristic) {
            this.name = name;
            this.value = value;
            this.isCharacteristic = isCharacteristic;
        }

        public String getName() {
            return this.name;
        }

        public boolean isCharacteristic() {
            return this.isCharacteristic;
        }

        public double getValue() {
            return this.value;
        }

        @Override
        public String toString() {
            return name + " (" + value + ")";
        }
    }

    /*
     * Comparator to sort objects of type ClassTopicValue
     */
    class MyClassTopicComparator implements Comparator<ClassTopicValue> {

        @Override
        public int compare(
                final ClassTopicValue arg0,
                final ClassTopicValue arg1) {
            if (arg0.getValue() > arg1.getValue())
                return -1;
            else if (arg0.getValue() < arg1.getValue())
                return +1;
            return 0;
        }

    }

    public HashMap<Integer, Topic> getTopicTerms() {
        return topicTerms;
    }

    /**
     * @param args
     */
    public static void main(final String[] args) {

        final String outputFolder = "/Users/hen/tmp/_tomcat/New3000_40";
        final String inputPath = "topics.csv";
        final String topicTermPath = "topicTermMatrix.txt";

        final double significanceFactor = 10; //the factor that the probability value of a topic for class must be higher than
        //for the other class to deem the topic as distinctive for the class (lower = tentatively more topics)
        final double entropyThreshold = 0.9;

        final TopicDatabase determiner = new TopicDatabase();
        try {
            determiner.loadData(outputFolder + "/" + inputPath, outputFolder
                    + "/" + topicTermPath);
            determiner.determineDiscriminativeTopics(significanceFactor,
                    entropyThreshold);

            final HashMap<Integer, Topic> termList = determiner.topicTerms;
            final TreeSet<Integer> treeSet = new TreeSet<Integer>(
                    termList.keySet());
            for (final Integer key : treeSet) {
                System.out.println(termList.get(key));
            }

        } catch (final IOException ex) {
            ex.printStackTrace();
        }

    }

}
